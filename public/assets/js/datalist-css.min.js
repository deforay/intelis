(() => {
    let listActive;
    let hideTimeout; // To keep track of the timeout
    document.body.addEventListener('focusin', listShow);

    function listShow(e) {
        const input = target(e);
        if (!input) return;
        if (input.list) {
            const dl = input.list;
            input.datalist = dl;
            input.removeAttribute('list');
            dl.input = input;
            dl.setAttribute('tabindex', -1);
            input.addEventListener('input', listLimit);
            input.addEventListener('keydown', listControl);
            input.addEventListener('focusout', () => {
                hideTimeout = setTimeout(() => listHide(input.datalist), 100); // Delay the hiding
            });
            dl.addEventListener('keydown', listKey);
            dl.addEventListener('click', listSet);
        }
        const dl = input.datalist;
        if (dl && !dl.shown) {
            listHide(listActive);
            dl.shown = !0;
            listLimit(e);
            dl.style.width = input.offsetWidth + 'px';
            dl.style.left = input.offsetLeft + 'px';
            dl.style.display = 'block';
            listActive = dl;
        }
    }

    function listHide(dl) {
        if (dl && dl.shown) {
            dl.style.display = 'none';
            dl.shown = !1;
        }
    }

    function listLimit(e) {
        const input = target(e);
        if (!input || !input.datalist) return;

        // Clear previously selected class
        Array.from(input.datalist.getElementsByTagName('option')).forEach(opt => {
            opt.classList.remove('selected');
            opt.setAttribute('tabindex', 0);
            opt.style.display = 'block';
        });

        // Highlight the selected option if it matches the input value
        const selectedOption = Array.from(input.datalist.getElementsByTagName('option')).find(opt => opt.value === input.value);
        if (selectedOption) {
            selectedOption.classList.add('selected');
        }
    }


    function listControl(e) {
        const input = target(e);
        if (!input || !input.datalist) return;
        switch (e.keyCode) {
            case 40: {
                let opt = input.datalist.firstElementChild;
                if (!opt.offsetHeight) opt = visibleSibling(opt, 1);
                opt && opt.focus();
                break;
            }
            case 9:
                listHide(input.datalist);
                break;
            case 13:
            case 32:
                listSet(e);
                break;
        }
    }

    const keymap = { 33: -12, 34: 12, 38: -1, 40: 1 };

    function listKey(e) {
        const t = target(e);
        if (!t) return;
        const kc = e.keyCode, dir = keymap[kc], dl = t.parentElement;
        if (dir) {
            let opt = visibleSibling(t, dir);
            opt && opt.focus();
            e.preventDefault();
        } else if (kc === 9 || kc === 13 || kc === 32) {
            listSet(e);
        } else if (kc === 8) {
            dl.input.focus();
        } else if (kc === 27) {
            listHide(dl);
        }
    }

    function visibleSibling(opt, dir) {
        let newOpt = opt;
        do {
            if (dir < 0) {
                newOpt = newOpt.previousElementSibling;
            } else if (dir > 0) {
                newOpt = newOpt.nextElementSibling;
            }
            if (newOpt && newOpt.offsetHeight) {
                opt = newOpt;
                dir -= Math.sign(dir);
            }
        } while (newOpt && dir);
        return opt;
    }

    function listSet(e) {
        const t = target(e), dl = t && t.parentElement;
        if (!dl || !dl.input) return;
        clearTimeout(hideTimeout); // Clear the timeout
        dl.input.value = (t && t.value) || '';
        listHide(dl);
    }

    function target(t) {
        return t && t.target;
    }
})();
