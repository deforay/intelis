(() => {
    let listActive;
    let hideTimeout;
    let justSelected = false; // Prevent re-opening after selection
    document.body.addEventListener('focusin', listShow);

    function listShow(e) {
        const input = target(e);
        if (!input) return;

        // Don't re-open if we just selected an item
        if (justSelected) {
            justSelected = false;
            return;
        }

        if (input.list) {
            const dl = input.list;
            input.datalist = dl;
            input.removeAttribute('list');
            dl.input = input;
            dl.setAttribute('tabindex', -1);
            input.addEventListener('input', listLimit);
            input.addEventListener('keydown', listControl);
            input.addEventListener('focusout', () => {
                hideTimeout = setTimeout(() => listHide(input.datalist), 100);
            });
            dl.addEventListener('keydown', listKey);
            dl.addEventListener('click', listSet);
        }
        const dl = input.datalist;
        if (dl && !dl.shown) {
            listHide(listActive);
            dl.shown = !0;
            listLimit(e);
            dl.style.width = input.offsetWidth + 'px';
            dl.style.left = input.offsetLeft + 'px';
            dl.style.display = 'block';
            listActive = dl;
        }
    }

    function listHide(dl) {
        if (dl && dl.shown) {
            dl.style.display = 'none';
            dl.shown = !1;
        }
    }

    function listLimit(e) {
        const input = target(e);
        if (!input || !input.datalist) return;

        const options = Array.from(input.datalist.getElementsByTagName('option'));
        const inputVal = (input.value || '').toLowerCase().trim();

        options.forEach(opt => {
            opt.classList.remove('selected');
            opt.setAttribute('tabindex', 0);

            // Filter options based on input value
            const optText = (opt.textContent || opt.value || '').toLowerCase();
            const optValue = (opt.value || '').toLowerCase();
            if (inputVal === '' || optText.includes(inputVal) || optValue.includes(inputVal)) {
                opt.style.display = 'block';
            } else {
                opt.style.display = 'none';
            }
        });

        // Highlight the selected option if it matches the input value exactly
        const selectedOption = options.find(opt => opt.value === input.value);
        if (selectedOption) {
            selectedOption.classList.add('selected');
        }
    }

    function listControl(e) {
        const input = target(e);
        if (!input || !input.datalist) return;
        const kc = e.keyCode;

        switch (kc) {
            case 40: { // Down arrow
                let opt = getFirstVisibleOption(input.datalist);
                if (opt) opt.focus();
                e.preventDefault();
                break;
            }
            case 38: { // Up arrow
                let opt = getLastVisibleOption(input.datalist);
                if (opt) opt.focus();
                e.preventDefault();
                break;
            }
            case 9: // Tab
                listHide(input.datalist);
                break;
            case 13: { // Enter
                const selectedOpt = input.datalist.querySelector('option.selected');
                const firstVisible = getFirstVisibleOption(input.datalist);
                if (selectedOpt && selectedOpt.style.display !== 'none') {
                    setInputValue(input, selectedOpt.value);
                } else if (firstVisible) {
                    setInputValue(input, firstVisible.value);
                }
                listHide(input.datalist);
                e.preventDefault();
                break;
            }
            case 27: // Escape
                listHide(input.datalist);
                e.preventDefault();
                break;
        }
    }

    const keymap = { 33: -12, 34: 12, 38: -1, 40: 1 };

    function listKey(e) {
        const t = target(e);
        if (!t) return;
        const kc = e.keyCode, dir = keymap[kc], dl = t.parentElement;
        if (dir) {
            let opt = visibleSibling(t, dir);
            if (opt) opt.focus();
            e.preventDefault();
        } else if (kc === 9 || kc === 13 || kc === 32) {
            listSet(e);
        } else if (kc === 8) {
            dl.input.focus();
        } else if (kc === 27) {
            justSelected = true;
            listHide(dl);
            dl.input.focus();
        }
    }

    function visibleSibling(opt, dir) {
        let newOpt = opt;
        do {
            if (dir < 0) {
                newOpt = newOpt.previousElementSibling;
            } else if (dir > 0) {
                newOpt = newOpt.nextElementSibling;
            }
            if (newOpt && newOpt.offsetHeight) {
                opt = newOpt;
                dir -= Math.sign(dir);
            }
        } while (newOpt && dir);
        return opt;
    }

    function listSet(e) {
        const t = target(e), dl = t && t.parentElement;
        if (!dl || !dl.input) return;
        clearTimeout(hideTimeout);
        justSelected = true; // Prevent re-opening on focus
        // Use textContent if available, otherwise fall back to value
        const newValue = (t && (t.textContent || t.value)) || '';
        setInputValue(dl.input, newValue);
        listHide(dl);
        dl.input.focus();
    }

    function setInputValue(input, value) {
        if (input.value !== value) {
            input.value = value;
            // Dispatch change event for form validation and other listeners
            input.dispatchEvent(new Event('change', { bubbles: true }));
        }
    }

    function getFirstVisibleOption(dl) {
        const options = dl.getElementsByTagName('option');
        for (let i = 0; i < options.length; i++) {
            if (options[i].offsetHeight && options[i].style.display !== 'none') {
                return options[i];
            }
        }
        return null;
    }

    function getLastVisibleOption(dl) {
        const options = dl.getElementsByTagName('option');
        for (let i = options.length - 1; i >= 0; i--) {
            if (options[i].offsetHeight && options[i].style.display !== 'none') {
                return options[i];
            }
        }
        return null;
    }

    function target(t) {
        return t && t.target;
    }
})();
